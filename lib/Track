#pragma once

// lib
#include <iostream>
#include <vector>
#include "Group"
#include "SkatesStock"

#define MAX_PEOPLE 100

using namespace std;

// class Skating Track
class Track{
	private:
		int maxPeople;
		int people;
		int nGroups;
		double revenue;
		double expense;
		int time;
		int oldTime;
	public:
		vector<Group> gruppi;
		Stock pattini = Stock(24, 44, 6, 10); // size start, size end, number of stock, number of usage before maintenance
		Track(){
			maxPeople = MAX_PEOPLE;
			people = 0;
			nGroups = 0;
			revenue = 0;
			expense = 0;
			time = 0;
			oldTime = 0;
		}
		void updateTime(int t){
			oldTime = time;
			time = t;
			pattini.updateTime(time);
			calcExpense();
		}
		void calcExpense(){
			expense += 0.20*(double)(time-oldTime) + pattini.calcExpense();
		}
		int getPeople(){
			return people;
		}
		int getMax(){
			return maxPeople;
		}
		bool canAddGroup(Group group){
			if(group.getNPeople()+people > maxPeople) return false;
			else return true;
		}
		/* when a group is added to the track:
		 * - the time the group entered the track is updated
		 * - the number of groups in the track is updated
		 * - the group is added to the vector of groups
		 * - the number of people in the track is updated
		 * - the usage left before maintenance of the skates is decreased
		 * NOTE: if the group cannot be added because of too many people, the function returns -1
		 */
		int addGroup(Group group){
			if(group.getNPeople()+people > maxPeople){
				return -1;
			}else{
				group.setTimeEnter(time);
				nGroups++;
				gruppi.push_back(group);
				people += group.getNPeople();
				return people;
			}
		}
		/* when a group is removed from the track:
		 * - the number of people in the track is updated
		 * - the number of groups in the track is updated
		 * - the revenue is updated
		 * - the group is removed from the vector of groups
		 * - checks if the skates need maintenance
		 * NOTE: the time the group exited the track is updated in the main for log purposes (add to log the revenue from the group)
		 */
		int removeGroup(int i){
			people -= gruppi[i].getNPeople();
			nGroups--;
			revenue += calcRevenue(gruppi[i]);
			pattini.addStockForGroup(gruppi[i]);
			gruppi.erase(gruppi.begin()+i);
			return people;
		}
		int getNGroups(){
			return nGroups;
		}
		int getPeopleInGroup(int i){
			return gruppi[i].getNPeople();
		}
		Group getGroup(int i){
			return gruppi[i];
		}
		double getExpense(){
			return expense;
		}
		double getRevenue(){
			return revenue;
		}
		double calcRevenue(Group g){
			return (g.getTimeExit() - g.getTimeEnter())*10 / 100.00;
		}
};
